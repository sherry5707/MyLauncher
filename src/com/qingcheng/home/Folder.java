/*
* Copyright (C) 2014 MediaTek Inc.
* Modification based on code covered by the mentioned copyright
* and/or permission notice(s).
*/
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.qingcheng.home;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.AnimatorSet;
import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.annotation.TargetApi;
import android.content.Context;
import android.content.res.Resources;
import android.graphics.PointF;
import android.graphics.Rect;
import android.os.Build;
import android.os.SystemClock;
import android.renderscript.Allocation;
import android.renderscript.RenderScript;
import android.renderscript.ScriptIntrinsicBlur;
//import android.support.v4.widget.AutoScrollHelper;
import android.text.InputType;
import android.text.Selection;
import android.text.Spannable;
import android.util.AttributeSet;
import android.util.Log;
import android.view.ActionMode;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityManager;
import android.view.animation.AccelerateInterpolator;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.LinearLayout;
import android.widget.ScrollView;
import android.widget.TextView;

import com.qingcheng.home.FolderInfo.FolderListener;
import com.qingcheng.home.R;
import com.qingcheng.home.config.QCConfig;
import com.qingcheng.home.util.FastBlur;
import com.qingcheng.home.util.QCLog;
import com.mediatek.launcher3.ext.AllApps;
import com.mediatek.launcher3.ext.LauncherExtPlugin;
import com.mediatek.launcher3.ext.LauncherLog;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;



//sunfeng add @20150802 for folder start
import android.widget.RelativeLayout;
import android.widget.ImageView;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorMatrix;
import android.graphics.ColorMatrixColorFilter;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.app.WallpaperManager;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.util.DisplayMetrics;
import android.view.ViewGroup;
import android.view.View.MeasureSpec;
import android.view.View.OnClickListener;
import android.widget.FrameLayout;

import com.qingcheng.home.LauncherAnimUtils;
import com.qingcheng.home.CellLayout;
import com.qingcheng.home.CellLayout.LayoutParams;
import com.qingcheng.home.jni.ImageUtils;
//sunfeng add @20150802 for folder end
/**
 * Represents a set of icons chosen by the user or generated by the system.
 */
public class Folder extends LinearLayout implements DragSource, View.OnClickListener,
        View.OnLongClickListener, DropTarget, FolderListener, TextView.OnEditorActionListener,
        View.OnFocusChangeListener {
    private static final String TAG = "Launcher.Folder";
    private int mFolderContentsHeight;

    protected DragController mDragController;
    protected Launcher mLauncher;
    protected FolderInfo mInfo;

    static final int STATE_NONE = -1;
    static final int STATE_SMALL = 0;
    static final int STATE_ANIMATING = 1;
    static final int STATE_OPEN = 2;

    private static final int CLOSE_FOLDER_DELAY_MS = 150;

    private int mExpandDuration;
    private int mMaterialExpandDuration;
    private int mMaterialExpandStagger;
    protected CellLayout mContent;
	
	//sunfeng modfiy @20150802 for folder start
    //private ScrollView mScrollView;
    private ScrollLayout mScrollView;
    LinearLayout folderPageIndicator;
    LinearLayout folderContents;
    private int mFolderPageIndicatorHeight;
	
	//sunfeng modfiy @20150802 for folder end
    private final LayoutInflater mInflater;
    private final IconCache mIconCache;
    private int mState = STATE_NONE;
    private static final int REORDER_ANIMATION_DURATION = 230;
    private static final int REORDER_DELAY = 250;
    private static final int ON_EXIT_CLOSE_DELAY = 400;
    private boolean mRearrangeOnClose = false;
    private FolderIcon mFolderIcon;
    private int mMaxCountX;
    private int mMaxCountY;
    private int mMaxNumItems;
    private ArrayList<View> mItemsInReadingOrder = new ArrayList<View>();
    boolean mItemsInvalidated = false;
    private ShortcutInfo mCurrentDragInfo;
    private View mCurrentDragView;
    private boolean mIsExternalDrag;
    boolean mSuppressOnAdd = false;
    private int[] mTargetCell = new int[2];
    private int[] mPreviousTargetCell = new int[2];
    private int[] mEmptyCell = new int[2];
    private Alarm mReorderAlarm = new Alarm();
    private Alarm mOnExitAlarm = new Alarm();
    private int mFolderNameHeight;
    private Rect mTempRect = new Rect();
    private boolean mDragInProgress = false;
    private boolean mDeleteFolderOnDropCompleted = false;
    private boolean mSuppressFolderDeletion = false;
    private boolean mItemAddedBackToSelfViaIcon = false;
    FolderEditText mFolderName;
    private float mFolderIconPivotX;
    private float mFolderIconPivotY;

    private boolean mIsEditingName = false;
    private InputMethodManager mInputMethodManager;

    private static String sDefaultFolderName;
    private static String sHintText;

    private FocusIndicatorView mFocusIndicatorHandler;

    // We avoid measuring the scroll view with a 0 width or height, as this
    // results in CellLayout being measured as UNSPECIFIED, which it does
    // not support.
    private static final int MIN_CONTENT_DIMEN = 5;

    private boolean mDestroyed;

    //private AutoScrollHelper mAutoScrollHelper;

    private Runnable mDeferredAction;
    private boolean mDeferDropAfterUninstall;
    private boolean mUninstallSuccessful;

    //M: [OP09][CF] @{
    boolean mSupportEditAndHideApps;
    boolean mIsPageViewFolder = false;
    private View mDivider;

    //M: [OP09][CF] }@
    /**
     * Used to inflate the Workspace from XML.
     *
     * @param context The application's context.
     * @param attrs The attribtues set containing the Workspace's customization values.
     */
    public Folder(Context context, AttributeSet attrs) {
        super(context, attrs);

        LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
        setAlwaysDrawnWithCacheEnabled(false);
        mInflater = LayoutInflater.from(context);
        mIconCache = app.getIconCache();

        Resources res = getResources();
        if (!QCConfig.supportMultiCellInFolder) {
        	mMaxCountX = (int) grid.numColumns;
            // Allow scrolling folders when DISABLE_ALL_APPS is true.
            if (LauncherAppState.isDisableAllApps()) {
                mMaxCountY = mMaxNumItems = Integer.MAX_VALUE;
            } else {
                mMaxCountY = (int) grid.numRows;
                mMaxNumItems = mMaxCountX * mMaxCountY;
            }
		} else {
			mMaxCountX = 3;
	        mMaxCountY = 4;
	        int screenCount = Math.max(1, Math.min(5, QCConfig.maxScreenCountInFolder));
	        mMaxNumItems = screenCount*mMaxCountX * mMaxCountY ;
		}
        
        mInputMethodManager = (InputMethodManager)
                getContext().getSystemService(Context.INPUT_METHOD_SERVICE);

        mExpandDuration = res.getInteger(R.integer.config_folderExpandDuration);
        mMaterialExpandDuration = res.getInteger(R.integer.config_materialFolderExpandDuration);
        mMaterialExpandStagger = res.getInteger(R.integer.config_materialFolderExpandStagger);

        if (sDefaultFolderName == null) {
            sDefaultFolderName = res.getString(R.string.folder_name);
        }
        if (sHintText == null) {
            sHintText = res.getString(R.string.folder_hint_text);
        }
        mLauncher = (Launcher) context;
        // We need this view to be focusable in touch mode so that when text editing of the folder
        // name is complete, we have something to focus on, thus hiding the cursor and giving
        // reliable behvior when clicking the text field (since it will always gain focus on click).
        setFocusableInTouchMode(true);
        //M:[OP09][CF] @{
        mSupportEditAndHideApps = LauncherExtPlugin.getInstance().getWorkspaceExt(getContext())
                .supportEditAndHideApps();
        //M:[OP09][CF] }@
        
        //sunfeng add @20150812 start:
        mFolderContentsWidth  = mLauncher.mApplication.getPxforXLayout(true, R.dimen.folder_contents_width, 0);
        mFolderContentsHeight  = mLauncher.mApplication.getPxforXLayout(true, R.dimen.folder_contents_height, 0);
        //sunfeng add @20150812 end:
    }
	
	//sunfeng modfiy @20150802 for folder start
    DeviceProfile grid;
    LauncherAppState app ;
    int mFolderContentsWidth, mItemWidth, mItemHeigth;
    int mGridCellWidth, mGridCellHeigth;
    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        folderContents = (LinearLayout) findViewById(R.id.folder_contents);
        mScrollView = (ScrollLayout) findViewById(R.id.folder_pages);
        folderPageIndicator = (LinearLayout) findViewById(R.id.folder_page_indicator);
        mScrollView.setPageIndicator(this);
        ShowPageNumber(mScrollView.getChildCount(), mScrollView.getCurScreen());
//        folderContents.setBackgroundResource(R.drawable.folder_bg);
        
        mContent = (CellLayout) findViewById(R.id.folder_content);
        mDivider = findViewById(R.id.divider);
        mFocusIndicatorHandler = new FocusIndicatorView(getContext());
        mContent.addView(mFocusIndicatorHandler, 0);
        mFocusIndicatorHandler.getLayoutParams().height = FocusIndicatorView.DEFAULT_LAYOUT_SIZE;
        mFocusIndicatorHandler.getLayoutParams().width = FocusIndicatorView.DEFAULT_LAYOUT_SIZE;
        app = LauncherAppState.getInstance();
        grid = app.getDynamicGrid().getDeviceProfile();
        /// M: customize folder cell height to show text with two lines completely on CT project.
        //mGridCellWidth = grid.folderCellWidthPx;
        //mGridCellHeigth = LauncherExtPlugin.getInstance().getWorkspaceExt(getContext())
        //        .customizeFolderCellHeight(grid.folderCellHeightPx);
        mGridCellHeigth = mLauncher.mApplication.getPxforYLayout(true, R.dimen.folder_cell_height, 0);
        mGridCellWidth = mLauncher.mApplication.getPxforXLayout(true, R.dimen.folder_cell_width, 0);
        mContent.setCellDimensions(mGridCellWidth,mGridCellHeigth);

        mContent.setGridSize(mMaxCountX, mMaxCountY);
        mContent.getShortcutsAndWidgets().setMotionEventSplittingEnabled(false);
        mContent.setInvertIfRtl(true);
        mFolderName = (FolderEditText) findViewById(R.id.folder_name);
        mFolderName.setFolder(this);
        mFolderName.setOnFocusChangeListener(this);

        // We find out how tall the text view wants to be (it is set to wrap_content), so that
        // we can allocate the appropriate amount of space for it.
        int measureSpec = MeasureSpec.UNSPECIFIED;
        mFolderName.measure(measureSpec, measureSpec);
        folderPageIndicator.measure(measureSpec, measureSpec);
        mFolderPageIndicatorHeight = 84;
        mFolderNameHeight = mFolderName.getMeasuredHeight();
        
        // We disable action mode for now since it messes up the view on phones
        mFolderName.setCustomSelectionActionModeCallback(mActionModeCallback);
        mFolderName.setOnEditorActionListener(this);
        mFolderName.setSelectAllOnFocus(true);
        mFolderName.setInputType(mFolderName.getInputType() |
                InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS | InputType.TYPE_TEXT_FLAG_CAP_WORDS);
        //mAutoScrollHelper = new FolderAutoScrollHelper(mScrollView);
    }

    private ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
            return false;
        }

        public boolean onCreateActionMode(ActionMode mode, Menu menu) {
            return false;
        }

        public void onDestroyActionMode(ActionMode mode) {
        }

        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
            return false;
        }
    };

    public void onClick(View v) {
        Object tag = v.getTag();
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onClick: v = " + v + ", tag = " + tag);
        }
        /// M: disable the click event @{
        if (tag instanceof ShortcutInfo && !Launcher.isInEditMode()) {
            mLauncher.onClick(v);
        }
        /// @}
    }

    public boolean onLongClick(View v) {
        // Return if global dragging is not enabled
        if (!mLauncher.isDraggingEnabled()) return true;

        Object tag = v.getTag();
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onLongClick: v = " + v + ", tag = " + tag);
        }

        if (tag instanceof ShortcutInfo) {
            ShortcutInfo item = (ShortcutInfo) tag;
            if (!v.isInTouchMode()) {
                return false;
            }
            if (mSupportEditAndHideApps && !Launcher.isInEditMode()
                 && isPageViewFolder()) {
                 LauncherLog.d(TAG, "onLongClick: return because none edit mode");
                 return false;
            }

            mLauncher.getWorkspace().beginDragShared(v, this);

            mCurrentDragInfo = item;
            mEmptyCell[0] = item.cellX;
            mEmptyCell[1] = item.cellY;
            mCurrentDragView = v;
            
            //mContent.removeView(mCurrentDragView);
            removeCellIcon(mScrollView.getCurScreen(),item.cellY, mCurrentDragView);
            mInfo.remove(mCurrentDragInfo);
            //addScrollView();
            //setupContentDimensions(0);
            
            mDragInProgress = true;
            mItemAddedBackToSelfViaIcon = false;
        }
        return true;
    }

    public boolean isEditingName() {
        return mIsEditingName;
    }

    private String oldFolderName;
    public void startEditingFolderName() {
        mFolderName.setHint("");
        mIsEditingName = true;
        oldFolderName=mFolderName.getText().toString();
    }

    public void dismissEditingName() {
        mInputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
        doneEditingFolderName(true);
    }

    public void doneEditingFolderName(boolean commit) {
        /// M: [ALPS01250799] Get correct folder hint string before setting hint.
        sHintText = getResources().getString(R.string.folder_hint_text);
        mFolderName.setHint(sHintText);
        // Convert to a string here to ensure that no other state associated with the text field
        // gets saved.
        String newTitle = mFolderName.getText().toString();
        if(!(oldFolderName!=null &&oldFolderName.equals(newTitle))){
            mInfo.setTitle(newTitle);
            synchronized (LauncherModel.sBgLock) {
            	ItemInfo mItemInfo = LauncherModel.sBgItemsIdMap.get(mInfo.id);
                if (mItemInfo!=null) {
                	mItemInfo.title = newTitle;
                    LauncherModel.sBgItemsIdMap.put(mInfo.id, mItemInfo);
    			}
                FolderInfo mFolderInfo = LauncherModel.sBgFolders.get(mInfo.id);
                if (mFolderInfo!=null) {
					mFolderInfo.title = newTitle;
					LauncherModel.sBgFolders.put(mInfo.id, mFolderInfo);
				}
			}
        }
        /// M: [OP09] support all app & folder.
        if (mSupportEditAndHideApps && isPageViewFolder()) {
            LauncherModel.updateAllAppsItemInDatabase(mLauncher, mInfo);
        } else {
            LauncherModel.updateItemInDatabase(mLauncher, mInfo);
        }

        if (commit) {
            sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                    String.format(getContext().getString(R.string.folder_renamed), newTitle));
        }
        // In order to clear the focus from the text field, we set the focus on ourself. This
        // ensures that every time the field is clicked, focus is gained, giving reliable behavior.
        requestFocus();

        Selection.setSelection((Spannable) mFolderName.getText(), 0, 0);
        mIsEditingName = false;
    }

    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
        if (actionId == EditorInfo.IME_ACTION_DONE) {
            dismissEditingName();
            return true;
        }
        return false;
    }

    public View getEditTextRegion() {
        return mFolderName;
    }

    public CellLayout getContent() {
    	int mCur = mScrollView.getCurScreen();
    	
    	if (QCConfig.supportMultiCellInFolder) {
			if ((mScrollView.getChildCount()-1)>=mCur) {
				return (CellLayout)mScrollView.getChildAt(mCur);
			}
		}
    	
        return mContent;
    }

    /**
     * We need to handle touch events to prevent them from falling through to the workspace below.
     */
    @Override
    public boolean onTouchEvent(MotionEvent ev) {
        return true;
    }

    public void setDragController(DragController dragController) {
        mDragController = dragController;
    }

    void setFolderIcon(FolderIcon icon) {
        mFolderIcon = icon;
    }

    @Override
    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
        // When the folder gets focus, we don't want to announce the list of items.
        return true;
    }

    /**
     * @return the FolderInfo object associated with this folder
     */
    FolderInfo getInfo() {
        return mInfo;
    }

    private class GridComparator implements Comparator<ShortcutInfo> {
        int mNumCols;
        public GridComparator(int numCols) {
            mNumCols = numCols;
        }

        @Override
        public int compare(ShortcutInfo lhs, ShortcutInfo rhs) {
            int lhIndex = lhs.cellY * mNumCols + lhs.cellX;
            int rhIndex = rhs.cellY * mNumCols + rhs.cellX;
            return (lhIndex - rhIndex);
        }
    }

    private void placeInReadingOrder(ArrayList<ShortcutInfo> items) {
        int maxX = 0;
        int count = items.size();
        for (int i = 0; i < count; i++) {
            ShortcutInfo item = items.get(i);
            if (item.cellX > maxX) {
                maxX = item.cellX;
            }
        }

        GridComparator gridComparator = new GridComparator(maxX + 1);
        Collections.sort(items, gridComparator);
        final int countX = getContent().getCountX();
        for (int i = 0; i < count; i++) {
            int x = i % countX;
            int y = i / countX;
            ShortcutInfo item = items.get(i);
            item.cellX = x;
            item.cellY = y;
            
            // Add to debug that item's cellX or cellY changed Jing.Wu 20160826 start
            synchronized (LauncherModel.sBgLock) {
            	ItemInfo mBgItemInfo = LauncherModel.sBgItemsIdMap.get(item.id);
            	if (mBgItemInfo!=null) {
            		mBgItemInfo.cellX = x;
                	mBgItemInfo.cellY = y;
                	LauncherModel.sBgItemsIdMap.put(item.id, mBgItemInfo);
				}
			}
            // Add to debug that item's cellX or cellY changed Jing.Wu 20160826 end
        }
    }

    void bind(FolderInfo info) {
        mInfo = info;
        ArrayList<ShortcutInfo> children = info.contents;
        ArrayList<ShortcutInfo> overflow = new ArrayList<ShortcutInfo>();
        
		if (QCConfig.supportMultiCellInFolder) {
			addScrollView( );
		}
        
        setupContentForNumItems(children.size());
        placeInReadingOrder(children);
        int count = 0;
        for (int i = 0; i < children.size(); i++) {
        	CellLayout mCellLayout = null;
            ShortcutInfo child = (ShortcutInfo) children.get(i);
            int mOnePageItem = mMaxCountX * mMaxCountY;
            int pageID = i/mOnePageItem;
            if ((mScrollView.getChildCount()-1) < pageID) {
            	if (mScrollView.getChildAt(mScrollView.getChildCount()-1) != null) {
            		mCellLayout = (CellLayout)mScrollView.getChildAt(mScrollView.getChildCount()-1);
				}
				if (QCLog.DEBUG) {
					QCLog.e(TAG, "bind() and (mScrollView.getChildCount()-1) < pageID !!! childCount = "+mScrollView.getChildCount());
				}
			} else {
            	if (mScrollView.getChildAt(pageID) != null) {
            		mCellLayout = (CellLayout)mScrollView.getChildAt(pageID);
				}
			}
            
            if(mCellLayout == null){
            	mCellLayout = mContent;
            }
            
            if (createAndAddShortcut(mCellLayout,child) == null) {
                overflow.add(child);
            } else {
                count++;
            }
        }

        // We rearrange the items in case there are any empty gaps
        setupContentForNumItems(count);

        // If our folder has too many items we prune them from the list. This is an issue
        // when upgrading from the old Folders implementation which could contain an unlimited
        // number of items.
        for (ShortcutInfo item: overflow) {
            mInfo.remove(item);
            /// M: [OP09] support all app & folder.
            if (mSupportEditAndHideApps && isPageViewFolder()) {
                LauncherModel.deleteAllAppsItemFromDatabase(mLauncher, item);
            } else {
                LauncherModel.deleteItemFromDatabase(mLauncher, item);
            }
        }

        mItemsInvalidated = true;
        updateTextViewFocus();
        mInfo.addListener(this);

        if (!sDefaultFolderName.contentEquals(mInfo.title)) {
            mFolderName.setText(mInfo.title);
        } else {
            mFolderName.setText(sDefaultFolderName);
        }
        
        updateItemLocationsInDatabase();

        // In case any children didn't come across during loading, clean up the folder accordingly
        mFolderIcon.post(new Runnable() {
            public void run() {
                if (getItemCount() <= 1) {
                    replaceFolderWithFinalItem();
                }
            }
        });
    }

    /**
     * Creates a new UserFolder, inflated from R.layout.user_folder.
     *
     * @param context The application's context.
     *
     * @return A new UserFolder.
     */
    static Folder fromXml(Context context) {
        return (Folder) LayoutInflater.from(context).inflate(R.layout.user_folder, null);
    }

    /**
     * This method is intended to make the UserFolder to be visually identical in size and position
     * to its associated FolderIcon. This allows for a seamless transition into the expanded state.
     */
    private void positionAndSizeAsIcon() {
        if (!(getParent() instanceof DragLayer)) return;
        /*setScaleX(0.8f);
        setScaleY(0.8f);
        setAlpha(0f);*/
        setScaleX(0.2f);
        setScaleY(0.2f);
        setAlpha(1.0f);
        mState = STATE_SMALL;
    }

    private void prepareReveal() {
        if (QCLog.DEBUG) {
			QCLog.d(TAG, "prepareReveal() and setScaleX("+1+")");
		}
        setScaleX(1f);
        setScaleY(1f);
        setAlpha(1f);
        mState = STATE_SMALL;
    }
    
    //add by zhangkun for folder blur effect 2013-08-07
    private static boolean toConformBitmap(Bitmap background, Bitmap foreground) {
	    if (background == null) {
		    return false;
	    }

	    int bw = background.getWidth();
	    int bh = background.getHeight();
	    int fw = foreground.getWidth();
	    int fh = foreground.getHeight();		

	    Canvas cv = new Canvas(background);
	    cv.drawBitmap(background, 0, 0, null);
	    cv.drawBitmap(foreground, (bw - fw)/2, (bh - fh)/2, null);
	    cv.save(Canvas.ALL_SAVE_FLAG);
	    cv.restore();	
	    return true;
    }
	
    public Bitmap getScreenshotsForCurrentWindow() {
	    WallpaperManager wallpaperManager = WallpaperManager
		    .getInstance(mLauncher);
	    BitmapDrawable mDrawable = null;
	    if (wallpaperManager.getWallpaperInfo() == null) {
	    	mDrawable = (BitmapDrawable)wallpaperManager.getDrawable();
		} else {
			mDrawable = (BitmapDrawable)wallpaperManager.getWallpaperInfo().loadThumbnail(mLauncher.getPackageManager());
		}
	    Bitmap bkgBitmap = mDrawable.getBitmap();
	    Bitmap positionBkgBitmap = null;
	    
	    int x = 0;
	    int y =0;
	    int width = Math.min(bkgBitmap.getWidth(), (int)LauncherApplication.getScreenWidthPixel());
	    int height = bkgBitmap.getHeight();
	    
	    if (bkgBitmap.getWidth()>(int)LauncherApplication.getScreenWidthPixel()) {
	    	float step = 0;
	    	step = (bkgBitmap.getWidth() - LauncherApplication.getScreenWidthPixel())
	    			/ (mLauncher.getWorkspace().getNormalChildCount()-1);
	    	int currentScreen = Math.min(mLauncher.getWorkspace().getNormalChildCount(), 
	    			mLauncher.getCurrentWorkspaceScreen()-(mLauncher.getWorkspace().hasCustomContent()?1:0));
	    	x = (int)(currentScreen * step);
		}
	    try {
			positionBkgBitmap = Bitmap.createBitmap(bkgBitmap, x, y,width,height).copy(Bitmap.Config.ARGB_8888, true);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			positionBkgBitmap = bkgBitmap;
		}
	    
//		toConformBitmap(positionBkgBitmap, bkgBitmap);
//		Bitmap bmpall = small(positionBkgBitmap, 0.2f, 0.2f);
//	    Bitmap bmpOut = Bitmap.createBitmap(bmpall.getWidth(), bmpall.getHeight(), Bitmap.Config.ARGB_8888); 		

	    int smallWidth = (int)(720*(0.2f));
		int smallHeight = (int)((smallWidth*positionBkgBitmap.getHeight())/positionBkgBitmap.getWidth());
		
		Bitmap smallBitmap = null;
		if (smallWidth < positionBkgBitmap.getWidth()) {
			smallBitmap = Bitmap.createScaledBitmap(positionBkgBitmap, smallWidth, smallHeight, true);
		} else {
			smallBitmap = positionBkgBitmap;
		}
	    //int progress = 1;   
	    float contrast = 0.4f;//(float) ((progress + 30) / 128.0);  
	    ColorMatrix cMatrix = new ColorMatrix();  
	    cMatrix.set(new float[] { contrast, 0, 0, 0, 0, 0,  
		    contrast, 0, 0, 0,   
		    0, 0, contrast, 0, 0, 0, 0, 0, 1, 0 });  

	    Paint paint = new Paint();  
	    paint.setColorFilter(new ColorMatrixColorFilter(cMatrix));  

	    Canvas canvas = new Canvas(smallBitmap);  
	    canvas.drawBitmap(smallBitmap, 0, 0, paint); 
	    //add by zhangkun 2013-08-07 for gausscian blur effect
		//vv.setDrawingCacheEnabled(false);
	    //end add
//	    if(positionBkgBitmap.isRecycled() == false){
//		    positionBkgBitmap.recycle();
//		    positionBkgBitmap = null;
//	    }
//            
//	    if(bmp.isRecycled() == false){
//		    bmp.recycle();
//		    bmp = null;
//	    }  

//	    if(bmpall.isRecycled() == false){
//		    bmpall.recycle();
//		    bmpall = null;
//	    }
	    return smallBitmap;
    }

    private static Bitmap small(Bitmap bitmap, float sx, float sy) {
	    Matrix matrix = new Matrix();
	    matrix.postScale(sx, sy);
	    Bitmap resizeBmp = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(),
			    bitmap.getHeight(), matrix, true);
	    return resizeBmp;
    }

    private static Object mGauss = new Object();

    public void GausscianBlur() {
	    synchronized (mGauss) {
		    Bitmap bitmapIn = getScreenshotsForCurrentWindow();
		    
		    blur(bitmapIn, mLauncher.mBlurImageView);

		    mLauncher.mBlurImageView.setScaleX(1.0f);
		    mLauncher.mBlurImageView.setScaleY(1.0f);
		    mLauncher.mBlurImageView.setAlpha(0.0f);
	    	
		    PropertyValuesHolder alpha = PropertyValuesHolder
			    .ofFloat("alpha", 1.0f);
		    PropertyValuesHolder scaleX = PropertyValuesHolder
			    .ofFloat("scaleX", 1.0f);
		    PropertyValuesHolder scaleY = PropertyValuesHolder
			    .ofFloat("scaleY", 1.0f);

		    ObjectAnimator oa = LauncherAnimUtils
			    .ofPropertyValuesHolder(
					    mLauncher.mBlurImageView, alpha,
					    scaleX, scaleY);
		    oa.setDuration(mLauncher.getResources().getInteger(R.integer.config_folderExpandDuration));
		    oa.start();

		    if (bitmapIn.isRecycled() == false) {
			    bitmapIn.recycle();
			    bitmapIn = null;
		    }
		    System.gc();
	    }
    }
    //end add
    @TargetApi(Build.VERSION_CODES.KITKAT)
    private void blur(Bitmap bkg, View view) {
    	long startMs = System.currentTimeMillis();
    	float radius = 7;
    	
        // method 1. use google RenderScript
    	//Bitmap overlay = Bitmap.createBitmap((int)(view.getMeasuredWidth()), (int)(view.getMeasuredHeight()), Bitmap.Config.ARGB_8888);
//        Bitmap overlay = Bitmap.createBitmap(bkg.getWidth(), bkg.getHeight(), Bitmap.Config.ARGB_8888);
//        Canvas canvas = new Canvas(overlay);
        //canvas.translate(-view.getLeft(), -view.getTop());
//        canvas.drawBitmap(bkg, 0, 0, null);
        
//        RenderScript rs = RenderScript.create(mLauncher);
//        Allocation overlayAlloc = Allocation.createFromBitmap(rs, overlay);
//        ScriptIntrinsicBlur blur = ScriptIntrinsicBlur.create(rs, overlayAlloc.getElement());
//        blur.setInput(overlayAlloc);
//        blur.setRadius(radius);
//        blur.forEach(overlayAlloc);
//        overlayAlloc.copyTo(overlay);
//        view.setBackground(new BitmapDrawable(getResources(), overlay));
//        rs.destroy();
        
        // method 2. use java FastBlur
//        overlay = FastBlur.doBlur(overlay, (int)radius, true);
//        view.setBackground(new BitmapDrawable(getResources(), overlay));
	    
	    // method 3. use jni FastBlur
        Bitmap bitmapOut = Bitmap.createBitmap(bkg.getWidth(),
        		bkg.getHeight(), Bitmap.Config.ARGB_8888);
        
	    if (bkg != null) {
                try {
                	if (QCLog.DEBUG) {
						QCLog.d(TAG, "GausscianBlur and nativeToBlur()");
					}
                    ImageUtils.nativeToBlur(bkg, bitmapOut, (int)radius);
                } catch (Exception e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
	    }
	    mLauncher.mBlurImageView.setImageBitmap(bitmapOut);
        
        if (QCLog.DEBUG) {
			QCLog.d(TAG, "blur() and use "+(System.currentTimeMillis() - startMs)+" ms");
		}
    }
    
    private int calcPivotX(){   
    	int mPivotX = 0;
        int mCellX = mFolderIcon.getFolderInfo().cellX;
    	if(mCellX == 0){
    		mPivotX = 0 - mFolderIcon.getFolder().mTempRect.left;
    	}else if(mCellX == 1){
    		mPivotX = mFolderIcon.getFolder().mTempRect.right - mContent.getCellWidth();
    	}else if(mCellX == 2){
    		mPivotX = mFolderIcon.getFolder().mTempRect.right - mContent.getCellWidth();
    	}else if(mCellX == 3){
    		mPivotX = mFolderIcon.getFolder().mTempRect.right - mFolderIcon.getWidth()/2;
    	}
    	return mPivotX;
    }
    
    private int calcPivotY(){   
    	int mPivotY = 0;
    	int mCellY = mFolderIcon.getFolderInfo().cellY;
    	int top = mFolderIcon.getFolder().mTempRect.top;
    	int mMaxCountY = mFolderIcon.getFolder().mMaxCountY;
    	int mCountY = mContent.getCountY();
    	int distance = (mMaxCountY - mCountY) * mFolderIcon.getAvailableSpaceInPreview();
    	
    	if(mCellY == 0){
			mPivotY = top - mContent.getCellHeight();
    	}else if(mCellY == 1){
    		mPivotY = top - mFolderIcon.getAvailableSpaceInPreview();
    	}else if(mCellY == 2){
    		mPivotY = top - mFolderNameHeight - mFolderPageIndicatorHeight;
    	}else if(mCellY == 3){
    		mPivotY = top - mFolderIcon.getPreviewOffsetY();
    	}else if(mCellY == 4){ //add by zhangkun 2013-11-22 for 4x6 desktop
    		mPivotY = top - mFolderIcon.getPreviewOffsetY();
    	} //end add	
    	return mPivotY - distance;
    }
    
    //sunfeng modify 20150813 start:
    public void animateOpen() { 
        //Add by keguoqing for vistor mode 20140226
         mFolderName.setEnabled(true); 
        //end
        positionAndSizeAsIcon();

        if (!(getParent() instanceof DragLayer)) return;
        centerAboutIcon();
        // add by zhangkun for folder blur effect 2013-08-07
        int folderPivotX = calcPivotX();
        int folderPivotY = calcPivotY();
        setPivotX(folderPivotX);
        setPivotY(folderPivotY);
        //end add
        PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 1);
        PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1.0f);
        PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1.0f);
        final ObjectAnimator oa = mOpenCloseAnimator =
            LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);

        oa.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
                sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                        String.format(getContext().getString(R.string.folder_opened),
                        mContent.getCountX(), mContent.getCountY()));
                mState = STATE_ANIMATING;
            }
            @Override
            public void onAnimationEnd(Animator animation) {
                mState = STATE_OPEN;
                setLayerType(LAYER_TYPE_NONE, null);
//                Cling cling = mLauncher.showFirstRunFoldersCling();
//                if (cling != null) {
//                    cling.bringToFront();
//                }
                setFocusOnFirstChild();
            }
        });
        oa.setDuration(mExpandDuration);
        setLayerType(LAYER_TYPE_HARDWARE, null);
        buildLayer();
        post(new Runnable() {
            public void run() {
                // Check if the animator changed in the meantime
                if (oa != mOpenCloseAnimator)
                    return;
                oa.start();
            }
        });
    }
    
//    public void animateOpen() {
//        /**M: Update unread number of content shortcuts.@{**/
//        updateContentUnreadNum();
//        /**@}**/
//
//        //M:[OP09][CF]@{
//        if (mSupportEditAndHideApps && Launcher.isInEditMode()) {
//            LauncherLog.d(TAG, "animateOpen, update delete button");
//            updateContentDeleteButton();
//        }
//        //M:[OP09][CF] }@
//        if (!(getParent() instanceof DragLayer)) return;
//
//        Animator openFolderAnim = null;
//        final Runnable onCompleteRunnable;
//        if (!Utilities.isLmpOrAbove()) {
//            positionAndSizeAsIcon();
//            centerAboutIcon();
//            
//            int folderPivotX = calcPivotX();
//            int folderPivotY = calcPivotY();
//            setPivotX(folderPivotX);
//            setPivotY(folderPivotY);
//            
//            PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 1);
//            PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1.0f);
//            PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1.0f);
//            final ObjectAnimator oa =
//                LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);
//            oa.setDuration(mExpandDuration);
//            openFolderAnim = oa;
//
//            setLayerType(LAYER_TYPE_HARDWARE, null);
//            onCompleteRunnable = new Runnable() {
//                @Override
//                public void run() {
//                    setLayerType(LAYER_TYPE_NONE, null);
//                }
//            };
//        } else {
//            prepareReveal();
//            centerAboutIcon();
//
//            int width = getPaddingLeft() + getPaddingRight() + mContent.getDesiredWidth();
//            int height = getFolderHeight();
//
//            float transX = - 0.075f * (width / 2 - getPivotX());
//            float transY = - 0.075f * (height / 2 - getPivotY());
//            setTranslationX(transX);
//            setTranslationY(transY);
//            PropertyValuesHolder tx = PropertyValuesHolder.ofFloat("translationX", transX, 0);
//            PropertyValuesHolder ty = PropertyValuesHolder.ofFloat("translationY", transY, 0);
//
//            int rx = (int) Math.max(Math.max(width - getPivotX(), 0), getPivotX());
//            int ry = (int) Math.max(Math.max(height - getPivotY(), 0), getPivotY());
//            float radius = (float) Math.sqrt(rx * rx + ry * ry);
//            AnimatorSet anim = LauncherAnimUtils.createAnimatorSet();
//            /**M: [Changes]If the hardware is accelerated, then allow to use Reveal animator.@{**/
//            boolean isHardwareAccelerated = this.isHardwareAccelerated();
//            Animator reveal = null;
//            if (isHardwareAccelerated) {
//                reveal = LauncherAnimUtils.createCircularReveal(this, (int) getPivotX(),
//                        (int) getPivotY(), 0, radius);
//                reveal.setDuration(mMaterialExpandDuration);
//                reveal.setInterpolator(new LogDecelerateInterpolator(100, 0));
//            }
//            /**@}**/
//
//               	mContent.setAlpha(0f);
//         
//            Animator iconsAlpha = LauncherAnimUtils.ofFloat(mContent, "alpha", 0f, 1f);
//            iconsAlpha.setDuration(mMaterialExpandDuration);
//            iconsAlpha.setStartDelay(mMaterialExpandStagger);
//            iconsAlpha.setInterpolator(new AccelerateInterpolator(1.5f));
//
//            mFolderName.setAlpha(0f);
//            Animator textAlpha = LauncherAnimUtils.ofFloat(mFolderName, "alpha", 0f, 1f);
//            textAlpha.setDuration(mMaterialExpandDuration);
//            textAlpha.setStartDelay(mMaterialExpandStagger);
//            textAlpha.setInterpolator(new AccelerateInterpolator(1.5f));
//
//            Animator drift = LauncherAnimUtils.ofPropertyValuesHolder(this, tx, ty);
//            drift.setDuration(mMaterialExpandDuration);
//            drift.setStartDelay(mMaterialExpandStagger);
//            drift.setInterpolator(new LogDecelerateInterpolator(60, 0));
//
//            anim.play(drift);
//            anim.play(iconsAlpha);
//            anim.play(textAlpha);
//            /**M: [Changes]If the hardware is accelerated, then allow to use Reveal animator.@{**/
//            if (isHardwareAccelerated) {
//                anim.play(reveal);
//            }
//            /**@}**/
//
//            openFolderAnim = anim;
//
//            mContent.setLayerType(LAYER_TYPE_HARDWARE, null);
//            onCompleteRunnable = new Runnable() {
//                @Override
//                public void run() {
//                    mContent.setLayerType(LAYER_TYPE_NONE, null);
//                }
//            };
//        }
//        openFolderAnim.addListener(new AnimatorListenerAdapter() {
//            @Override
//            public void onAnimationStart(Animator animation) {
//                sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
//                        String.format(getContext().getString(R.string.folder_opened),
//                        mContent.getCountX(), mContent.getCountY()));
//                mState = STATE_ANIMATING;
//            }
//            @Override
//            public void onAnimationEnd(Animator animation) {
//                mState = STATE_OPEN;
//                
//                /// M: if open folder animation ended, set alpha and scale as 1 @{ 
//                setAlpha(1f);
//                setScaleX(1f);
//                setScaleY(1f);
//                /// end @}
//                
//
//                if (onCompleteRunnable != null) {
//                    onCompleteRunnable.run();
//                }
//
//                setFocusOnFirstChild();
//            }
//        });
//        openFolderAnim.start();
//
//        // Make sure the folder picks up the last drag move even if the finger doesn't move.
//        if (mDragController.isDragging()) {
//            mDragController.forceTouchMove();
//        }
//    }

    public void beginExternalDrag(ShortcutInfo item) {
        setupContentForNumItems(getItemCount() + 1);

        // Add for open folder Jing.Wu 20151105 start
        if (QCConfig.supportMultiCellInFolder) {
        	int mAllSize = mInfo.contents.size();
        	int mOnePageItem = mMaxCountX * mMaxCountY;
        	int totalContentNumb = (mAllSize/mOnePageItem)+1;
        	int currentChildContentNumb = mScrollView.getChildCount();
        	if (currentChildContentNumb!=totalContentNumb) {
            	if (currentChildContentNumb<totalContentNumb) {
        			for (int i = currentChildContentNumb; i < totalContentNumb; i++) {
        				addContent();
        			}
        		} else if (currentChildContentNumb>totalContentNumb) {
        			mScrollView.removeViews(totalContentNumb, (currentChildContentNumb-totalContentNumb));
        		}
    		}
    		mScrollView.postInvalidate();
    		ShowPageNumber(mScrollView.getChildCount(), mScrollView.getCurScreen());
		}
    
        CellLayout mCellLayout = null;
        if (mScrollView.getChildAt(mScrollView.getChildCount()-1) != null) {
			mCellLayout = (CellLayout)mScrollView.getChildAt(mScrollView.getChildCount()-1);
			mScrollView.setToScreen(mScrollView.getChildCount()-1);
		} else {
			mCellLayout = mContent;
			mScrollView.setToScreen(0);
		}
        // Add for open folder Jing.Wu 20151105 end
        
        findAndSetEmptyCells(mCellLayout,item);

        mCurrentDragInfo = item;
        mEmptyCell[0] = item.cellX;
        mEmptyCell[1] = item.cellY;
        mIsExternalDrag = true;
        mDragInProgress = true;
    }

    private void sendCustomAccessibilityEvent(int type, String text) {
        AccessibilityManager accessibilityManager = (AccessibilityManager)
                getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
        if (accessibilityManager.isEnabled()) {
            AccessibilityEvent event = AccessibilityEvent.obtain(type);
            onInitializeAccessibilityEvent(event);
            event.getText().add(text);
            accessibilityManager.sendAccessibilityEvent(event);
        }
    }

    private void setFocusOnFirstChild() {
        View firstChild = mContent.getChildAt(0, 0);
        if (firstChild != null) {
            firstChild.requestFocus();
        }
    }

    private ObjectAnimator mOpenCloseAnimator;
    
    public void animateClosed() {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "animateClosed: parent = " + getParent());
        }
        mScrollView.snapToScreen(0);
        if (!(getParent() instanceof DragLayer)) return;
        PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 1.0f);
        PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 0.2f);
        PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 0.2f);
        final ObjectAnimator oa = mOpenCloseAnimator =
                LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);

        oa.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                onCloseComplete();
                setLayerType(LAYER_TYPE_NONE, null);
                mState = STATE_SMALL;
        		mLauncher.mBlurImageView.setImageBitmap(null);
        		mLauncher.mBlurImageView.setBackground(null);
            }
            @Override
            public void onAnimationStart(Animator animation) {
                sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                        getContext().getString(R.string.folder_closed));
                mState = STATE_ANIMATING;
            }
        });
        oa.setDuration(mExpandDuration);
        setLayerType(LAYER_TYPE_HARDWARE, null);
        buildLayer();
        post(new Runnable() {
            public void run() {
                // Check if the animator changed in the meantime
                if (oa != mOpenCloseAnimator)
                    return;
                oa.start();
            }
        });
    }
    

    public boolean acceptDrop(DragObject d) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "acceptDrop: DragObject = " + d);
        }

        final ItemInfo item = (ItemInfo) d.dragInfo;
        final int itemType = item.itemType;
        return ((itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
                    itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) &&
                    !isFull());
    }

    //sunfeng modify 20150813 end:
    
    /***
     * set Item  X Y 
     * @param item
     * @return
     */
    protected boolean findAndSetEmptyCells(CellLayout mCelllayout,ShortcutInfo item) {
        int[] emptyCell = new int[2];
        if (mCelllayout.findCellForSpan(emptyCell, item.spanX, item.spanY)) {
            item.cellX = emptyCell[0];
            item.cellY = emptyCell[1];
            return true;
        } else {
            return false;
        }
    }

    protected View createAndAddShortcut(CellLayout mCelllayout,ShortcutInfo item) {
        final BubbleTextView textView =
            (BubbleTextView) mInflater.inflate(R.layout.application, this, false);
        textView.applyFromShortcutInfo(item, mIconCache, true);
        /** M: Modified for Unread feature. Update unread number of folder icon.@**/
        mFolderIcon.updateFolderUnreadNum(item.intent.getComponent(), item.unreadNum);
        /**@}**/

        //M:[OP09][CF]@{
        if (mSupportEditAndHideApps && Launcher.isInEditMode()) {
            final AppsCustomizePagedView pageview = mLauncher.getPagedView();
            if (!pageview.isSystemApp(item.makeAppInfo())) {
                LauncherLog.d(TAG, "createAndAddShortcut: item = " + item);
                textView.setDeleteButtonVisibility(true);
                textView.setOnTouchListener(pageview);
            }
        }
        //M:[OP09][CF] }@
        

        textView.setOnClickListener(this);
        textView.setOnLongClickListener(this);
        textView.setOnFocusChangeListener(mFocusIndicatorHandler);

        // We need to check here to verify that the given item's location isn't already occupied
        // by another item.
        if (mCelllayout.getChildAt(item.cellX, item.cellY) != null || item.cellX < 0 || item.cellY < 0
                || item.cellX >= mCelllayout.getCountX() || item.cellY >= mCelllayout.getCountY()) {
            // This shouldn't happen, log it.
            Log.e(TAG, "Folder order not properly persisted during bind");
            if (QCLog.DEBUG) {
				QCLog.d(TAG, "findAndSetEmptyCells, and mCelllayout = "+mCelllayout+", item = "+item);
				QCLog.d(TAG, "mCelllayout.getChildAt(item.cellX, item.cellY) != null ? = "
						+(mCelllayout.getChildAt(item.cellX, item.cellY) != null));
				QCLog.d(TAG, "mCelllayout.getCountX() = "+mCelllayout.getCountX()
						+", mCelllayout.getCountY() = "+mCelllayout.getCountY());
			}
            if (!findAndSetEmptyCells(mCelllayout,item)) {
                return null;
            }
        }

        CellLayout.LayoutParams lp =
            new CellLayout.LayoutParams(item.cellX, item.cellY, item.spanX, item.spanY);
        boolean insert = false;
        textView.setOnKeyListener(new FolderKeyEventListener());
        
    	mCelllayout.addViewToCellLayout(textView, insert ? 0 : -1, (int)item.id, lp, true);
// 		addViewContent(item.cellY,textView,  insert ? 0 : -1, (int)item.id, lp, true);
    	
        return textView;
    }

    public void onDragEnter(DragObject d) {	

        mPreviousTargetCell[0] = -1;
        mPreviousTargetCell[1] = -1;
        mOnExitAlarm.cancelAlarm();
    }

    OnAlarmListener mReorderAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
            realTimeReorder(mEmptyCell, mTargetCell);
        }
    };

    boolean readingOrderGreaterThan(int[] v1, int[] v2) {
        if (v1[1] > v2[1] || (v1[1] == v2[1] && v1[0] > v2[0])) {
            return true;
        } else {
            return false;
        }
    }

    private void realTimeReorder(int[] empty, int[] target) {
        boolean wrap;
        int startX;
        int endX;
        int startY;
        int delay = 0;
        CellLayout mTmp = getContent();//mContent;
//        if(mScrollView.getCurScreen() ==1){
//        	mTmp =mContent2;
//        }else if(mScrollView.getCurScreen()==2){
//        	mTmp = mContent3;
//        }
        
        float delayAmount = 30;
        if (readingOrderGreaterThan(target, empty)) {
            wrap = empty[0] >= mTmp.getCountX() - 1;
            startY = wrap ? empty[1] + 1 : empty[1];
            for (int y = startY; y <= target[1]; y++) {
                startX = y == empty[1] ? empty[0] + 1 : 0;
                endX = y < target[1] ? mTmp.getCountX() - 1 : target[0];
                for (int x = startX; x <= endX; x++) {
                    View v = mTmp.getChildAt(x,y);
                    if (mTmp.animateChildToPosition(v, empty[0], empty[1],
                            REORDER_ANIMATION_DURATION, delay, true, true)) {
                        empty[0] = x;
                        empty[1] = y;
                        delay += delayAmount;
                        delayAmount *= 0.9;
                    }
                }
            }
        } else {
            wrap = empty[0] == 0;
            startY = wrap ? empty[1] - 1 : empty[1];
            for (int y = startY; y >= target[1]; y--) {
                startX = y == empty[1] ? empty[0] - 1 : mTmp.getCountX() - 1;
                endX = y > target[1] ? 0 : target[0];
                for (int x = startX; x >= endX; x--) {
                    View v = getContent().getChildAt(x,y);
                    if (mTmp.animateChildToPosition(v, empty[0], empty[1],
                            REORDER_ANIMATION_DURATION, delay, true, true)) {
                        empty[0] = x;
                        empty[1] = y;
                        delay += delayAmount;
                        delayAmount *= 0.9;
                    }
                }
            }
        }
    }

    public boolean isLayoutRtl() {
        return (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
    }

    public void onDragOver(DragObject d) {
    	
        final DragView dragView = d.dragView;
        final int scrollOffset = getContent().getScrollY();
        final float[] r = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, dragView, null);
        r[0] -= getPaddingLeft();
        r[1] -= getPaddingTop();

//        final long downTime = SystemClock.uptimeMillis();
//        final MotionEvent translatedEv = MotionEvent.obtain(
//                downTime, downTime, MotionEvent.ACTION_MOVE, d.x, d.y, 0);

//        if (!mAutoScrollHelper.isEnabled()) {
//            mAutoScrollHelper.setEnabled(true);
//        }

//        final boolean handled = mAutoScrollHelper.onTouch(this, translatedEv);
//        translatedEv.recycle();
        
        //if (handled) {
        //	mReorderAlarm.cancelAlarm();
        //} else {
            mTargetCell = getContent().findNearestArea(
                    (int) r[0], (int) r[1] + scrollOffset, 1, 1, mTargetCell);
            if (isLayoutRtl()) {
                mTargetCell[0] = getContent().getCountX() - mTargetCell[0] - 1;
            }
            if (mTargetCell[0] != mPreviousTargetCell[0]
                    || mTargetCell[1] != mPreviousTargetCell[1]) {
                mReorderAlarm.cancelAlarm();
                mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
                mReorderAlarm.setAlarm(REORDER_DELAY);
                mPreviousTargetCell[0] = mTargetCell[0];
                mPreviousTargetCell[1] = mTargetCell[1];
            }
       // }
    }

    // This is used to compute the visual center of the dragView. The idea is that
    // the visual center represents the user's interpretation of where the item is, and hence
    // is the appropriate point to use when determining drop location.
    private float[] getDragViewVisualCenter(int x, int y, int xOffset, int yOffset,
            DragView dragView, float[] recycle) {
        float res[];
        if (recycle == null) {
            res = new float[2];
        } else {
            res = recycle;
        }

        // These represent the visual top and left of drag view if a dragRect was provided.
        // If a dragRect was not provided, then they correspond to the actual view left and
        // top, as the dragRect is in that case taken to be the entire dragView.
        // R.dimen.dragViewOffsetY.
        int left = x - xOffset;
        int top = y - yOffset;

        // In order to find the visual center, we shift by half the dragRect
        res[0] = left + dragView.getDragRegion().width() / 2;
        res[1] = top + dragView.getDragRegion().height() / 2;

        return res;
    }

    OnAlarmListener mOnExitAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
            completeDragExit();
        }
    };

    public void completeDragExit() {
        mLauncher.closeFolder();
        mCurrentDragInfo = null;
        mCurrentDragView = null;
        mSuppressOnAdd = false;
        mRearrangeOnClose = true;
        mIsExternalDrag = false; 
        
    }

    public void onDragExit(DragObject d) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onDragExit: DragObject = " + d);
        }

        // Exiting folder; stop the auto scroller.
        //mAutoScrollHelper.setEnabled(false);
        
        // We only close the folder if this is a true drag exit, ie. not because
        // a drop has occurred above the folder.
        if (!d.dragComplete) {
            mOnExitAlarm.setOnAlarmListener(mOnExitAlarmListener);
            mOnExitAlarm.setAlarm(ON_EXIT_CLOSE_DELAY);
        }
        mReorderAlarm.cancelAlarm();
    }

    public void onDropCompleted(final View target, final DragObject d,
            final boolean isFlingToDelete, final boolean success) {

        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onDropCompleted: View = " + target + ", DragObject = " + d
                    + ", isFlingToDelete = " + isFlingToDelete + ", success = " + success);
        }

        if (mDeferDropAfterUninstall) {
            Log.d(TAG, "Deferred handling drop because waiting for uninstall.");
            mDeferredAction = new Runnable() {
                    public void run() {
                        onDropCompleted(target, d, isFlingToDelete, success);
                        mDeferredAction = null;
                    }
                };
            return;
        }

        boolean beingCalledAfterUninstall = mDeferredAction != null;
        boolean successfulDrop =
                success && (!beingCalledAfterUninstall || mUninstallSuccessful);

        if (successfulDrop) {
            if (mDeleteFolderOnDropCompleted && !mItemAddedBackToSelfViaIcon && target != this) {
                replaceFolderWithFinalItem();
            }
        } else {
            setupContentForNumItems(getItemCount());
            // The drag failed, we need to return the item to the folder
            mFolderIcon.onDrop(d);
        }

        if (target != this) {
            if (mOnExitAlarm.alarmPending()) {
                mOnExitAlarm.cancelAlarm();
                if (!successfulDrop) {
                    mSuppressFolderDeletion = true;
                }
                completeDragExit();
            }
        }

        mDeleteFolderOnDropCompleted = false;
        mDragInProgress = false;
        mItemAddedBackToSelfViaIcon = false;
        mCurrentDragInfo = null;
        mCurrentDragView = null;
        mSuppressOnAdd = false;

        // Reordering may have occured, and we need to save the new item locations. We do this once
        // at the end to prevent unnecessary database operations.
        updateItemLocationsInDatabaseBatch();
    }

    public void deferCompleteDropAfterUninstallActivity() {
        mDeferDropAfterUninstall = true;
    }

    public void onUninstallActivityReturned(boolean success) {
        mDeferDropAfterUninstall = false;
        mUninstallSuccessful = success;
        if (mDeferredAction != null) {
            mDeferredAction.run();
        }
    }

    @Override
    public float getIntrinsicIconScaleFactor() {
        return 1f;
    }

    @Override
    public boolean supportsFlingToDelete() {
        return true;
    }

    @Override
    public boolean supportsAppInfoDropTarget() {
        return true;
    }

    @Override
    public boolean supportsDeleteDropTarget() {
        return true;
    }

    public void onFlingToDelete(DragObject d, int x, int y, PointF vec) {
        // Do nothing
    }

    @Override
    public void onFlingToDeleteCompleted() {
        // Do nothing
    }

    private void updateItemLocationsInDatabase() {
        ArrayList<View> list = getItemsInReadingOrder();
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            ItemInfo info = (ItemInfo) v.getTag();
            /// M: [OP09] support all app & folder.
            if (mSupportEditAndHideApps && isPageViewFolder()) {
                LauncherModel.moveAllAppsItemInDatabase(mLauncher, info, mInfo.id, 0,
                        info.cellX, info.cellY);
            } else {
                LauncherModel.moveItemInDatabase(mLauncher, info, mInfo.id, 0,
                        info.cellX, info.cellY);
            }
        }
    }

    private void updateItemLocationsInDatabaseBatch() {
        ArrayList<View> list = getItemsInReadingOrder();
        ArrayList<ItemInfo> items = new ArrayList<ItemInfo>();
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            ItemInfo info = (ItemInfo) v.getTag();
            items.add(info);
        }

        /// M: [OP09] support all app & folder.
        if (mSupportEditAndHideApps && isPageViewFolder()) {
            LauncherModel.moveAllAppsItemsInDatabase(mLauncher, items, mInfo.id, 0);
        } else {
            LauncherModel.moveItemsInDatabase(mLauncher, items, mInfo.id, 0);
        }
    }

    public void addItemLocationsInDatabase() {
        ArrayList<View> list = getItemsInReadingOrder();
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            ItemInfo info = (ItemInfo) v.getTag();
            
            /// M: [OP09] support all app & folder.
            if (mSupportEditAndHideApps && isPageViewFolder()) {
                LauncherModel.moveAllAppsItemInDatabase(mLauncher, info, mInfo.id, 0,
                        info.cellX, info.cellY);
            } else {
                LauncherModel.addItemToDatabase(mLauncher, info, mInfo.id, 0,
                        info.cellX, info.cellY, false);
            }
        }
    }

    public void notifyDrop() {
        if (mDragInProgress) {
            mItemAddedBackToSelfViaIcon = true;
        }
    }

    public boolean isDropEnabled() {
        return true;
    }

    private void setupContentDimensions(int count) {
        ArrayList<View> list = getItemsInReadingOrder();
        setGridSize();
        arrangeChildren(list);
    }
    
    private int getItemCountY(int count){
        int countY = 1;
        if (count % 4 == 0 && count >= 4) {
            countY = count/4;
        } else {
            countY = count/4+1;
        }
    	return countY;
    }
    
    private void setGridSize(){
    	int mNum = mInfo.contents.size();
    	int mOnePageItem = mMaxCountX * mMaxCountY;
    	if (QCConfig.supportMultiCellInFolder) {
			for (int i = 0; i < mScrollView.getChildCount(); i++) {
				if (mScrollView.getChildAt(i) != null) {
					((CellLayout)mScrollView.getChildAt(i)).setGridSize(mMaxCountX, mMaxCountY);
				}
			}
		} else {
			mContent.setGridSize(mMaxCountX, mMaxCountY);
		}
    }

    public boolean isFull() {
        return getItemCount() >= mMaxNumItems;
    }

    private void centerAboutIcon() {
        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();

        DragLayer parent = (DragLayer) mLauncher.findViewById(R.id.drag_layer);
        int width = getPaddingLeft() + getPaddingRight() + mContent.getDesiredWidth();
        int height = getFolderHeight();
        width = mFolderContentsWidth;
        float scale = parent.getDescendantRectRelativeToSelf(mFolderIcon, mTempRect);

        app = LauncherAppState.getInstance();
        grid = app.getDynamicGrid().getDeviceProfile();

        int centerX = (int) (mTempRect.left + mTempRect.width() * scale / 2);
        int centerY = (int) (mTempRect.top + mTempRect.height() * scale / 2);
        int centeredLeft = centerX - width / 2;
        int centeredTop = centerY - height / 2;

        Rect bounds = new Rect();
        if (mSupportEditAndHideApps && isPageViewFolder() && mLauncher.getPagedView() != null ) {
            AppsCustomizeCellLayout currentLayout = (AppsCustomizeCellLayout)
                       mLauncher.getPagedView().getPageAt((int) mInfo.screenId);
            int count = mLauncher.getPagedView().getChildCount();
            if (currentLayout != null) {
                ShortcutAndWidgetContainer boundingLayout = currentLayout.getShortcutsAndWidgets();
                parent.getDescendantRectRelativeToSelf(boundingLayout, bounds);
            }
        } else {
            int currentPage = mLauncher.getWorkspace().getNextPage();
            // In case the workspace is scrolling, we need to use the final scroll to compute
            // the folders bounds.
            mLauncher.getWorkspace().setFinalScrollForPageChange(currentPage);
            // We first fetch the currently visible CellLayoutChildren
            CellLayout currentLayout = (CellLayout) mLauncher.getWorkspace().getChildAt(currentPage);
            //modify @20150825 for JLLEL-342 start:
            if(currentLayout!=null){
	            ShortcutAndWidgetContainer boundingLayout = currentLayout.getShortcutsAndWidgets();
	            if(boundingLayout!=null){
	            	parent.getDescendantRectRelativeToSelf(boundingLayout, bounds);
	            }
            }
            //modify @20150825 for JLLEL-342 end:
            // We reset the workspaces scroll
            mLauncher.getWorkspace().resetFinalScrollForPageChange(currentPage);
        }

        Log.d(TAG, "centerAboutIcon now, after bounds = " + bounds
               + "mFolderIcon = " + mFolderIcon);

        // We need to bound the folder to the currently visible CellLayoutChildren
        int left = Math.min(Math.max(bounds.left, centeredLeft),
                bounds.left + bounds.width() - width);
        int top = Math.min(Math.max(bounds.top, centeredTop),
                bounds.top + bounds.height() - height);
        if (grid.isPhone() && (grid.availableWidthPx - width) < grid.iconSizePx) {
            // Center the folder if it is full (on phones only)
            left = (grid.availableWidthPx - width) / 2;
        } else if (width >= bounds.width()) {
            // If the folder doesn't fit within the bounds, center it about the desired bounds
            left = bounds.left + (bounds.width() - width) / 2;
        }
        if (height >= bounds.height()) {
            top = bounds.top + (bounds.height() - height) / 2;
        }

        // remove by zhangkun for folder blur effect 2013-08-07
        /*
        int folderPivotX = width / 2 + (centeredLeft - left);
        int folderPivotY = height / 2 + (centeredTop - top);
        setPivotX(folderPivotX);
        setPivotY(folderPivotY);
        mFolderIconPivotX = (int) (mFolderIcon.getMeasuredWidth() *
                (1.0f * folderPivotX / width));
        mFolderIconPivotY = (int) (mFolderIcon.getMeasuredHeight() *
                (1.0f * folderPivotY / height));
        */   
        //end remove

        lp.width = width;
        lp.height = height;
		//modify by zhangkun for folder blur effect 2013-08-07
        lp.x = (parent.getWidth() - width) / 2;;
        lp.y = 204;
		//end modify
    }

    float getPivotXForIconAnimation() {
        return mFolderIconPivotX;
    }
    float getPivotYForIconAnimation() {
        return mFolderIconPivotY;
    }

    private void setupContentForNumItems(int count) {
        setupContentDimensions(count);

        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
        if (lp == null) {
            lp = new DragLayer.LayoutParams(0, 0);
            lp.customPosition = true;
            setLayoutParams(lp);
        }
        centerAboutIcon();
    }

    private int getContentAreaHeight() {
        LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
        Rect workspacePadding = grid.getWorkspacePadding(grid.isLandscape ?
                CellLayout.LANDSCAPE : CellLayout.PORTRAIT);
        int maxContentAreaHeight = grid.availableHeightPx -
                workspacePadding.top - workspacePadding.bottom -
                mFolderNameHeight -mFolderPageIndicatorHeight;
        if(grid.isLandscape){
            maxContentAreaHeight -= LauncherApplication.statusBarHeight;
        }
        int wdiget = Math.min(maxContentAreaHeight,
        		mContent.getDesiredHeight());
        int height = Math.min(maxContentAreaHeight,
        		mContent.getDesiredHeight());
        return Math.max(height, MIN_CONTENT_DIMEN);
    }

    private int getContentAreaWidth() {
        return Math.max(mContent.getDesiredWidth(), MIN_CONTENT_DIMEN);
    }

    //sunfeng add @20150812 start:  
    private int getFolderHeight() {
        int offsetY = getOffsetYLand();
        //int height = getPaddingTop() + getPaddingBottom()
        //        + getContentAreaHeight() + mFolderNameHeight + mFolderPageIndicatorHeight;
        return mFolderContentsHeight + mFolderNameHeight - offsetY + 51 + 84;
    }

    private int getOffsetYLand() {
        LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
        int offsetY = 0;
        if(grid.isLandscape){
            offsetY += LauncherApplication.statusBarHeight;
        }
        return offsetY;
    }

    //sunfeng add @20150812 end:
    //sunfeng modfiy @20150803 for folder open height
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int width = mFolderContentsWidth;
        int height = getFolderHeight();
        int mWidth = MeasureSpec.makeMeasureSpec(width , MeasureSpec.EXACTLY);
        int mHeight = MeasureSpec.makeMeasureSpec(mFolderContentsHeight, MeasureSpec.EXACTLY);
        int mHeight2 = MeasureSpec.makeMeasureSpec(mFolderContentsHeight + 84, MeasureSpec.EXACTLY);

        mContent.setFixedSize(mWidth,mHeight);
        mContent.measure(mWidth, mHeight);
        mScrollView.measure(mWidth, mHeight);
        folderContents.measure(mWidth,mHeight2);

        mFolderName.measure(mWidth,
                MeasureSpec.makeMeasureSpec(mFolderNameHeight, MeasureSpec.EXACTLY));
        folderPageIndicator.measure(mWidth,
                MeasureSpec.makeMeasureSpec(mFolderPageIndicatorHeight, MeasureSpec.EXACTLY));
        mDivider.measure(MeasureSpec.makeMeasureSpec(720 , MeasureSpec.EXACTLY),
                MeasureSpec.makeMeasureSpec(3, MeasureSpec.EXACTLY));
        setMeasuredDimension(width , height);
    }
    
    /***
     * again  show View
     * @param list
     */
    private void arrangeChildren(ArrayList<View> list) {
        int[] vacant = new int[2];
        if (list == null) {
            list = getItemsInReadingOrder();
        }
        if (QCConfig.supportMultiCellInFolder) {
        	addScrollView( );
			for (int i = 0; i < mScrollView.getChildCount(); i++) {
				if (mScrollView.getChildAt(i) != null) {
					((CellLayout)mScrollView.getChildAt(i)).removeAllViews();
				}
			}
		} else {
			mContent.removeAllViews();
		}

        CellLayout mCellLayout = mContent;
        
        for (int i = 0; i < list.size(); i++) {
        	if (QCConfig.supportMultiCellInFolder) {
                int mOnePageItem = mMaxCountX * mMaxCountY;
        		int pageID = i/mOnePageItem;
                if ((mScrollView.getChildCount()-1) < pageID) {
    				mCellLayout = (CellLayout)mScrollView.getChildAt(mScrollView.getChildCount()-1);
    				if (QCLog.DEBUG) {
    					QCLog.e(TAG, "arrangeChildren() and (mScrollView.getChildCount()-1) < pageID !!! childCount = "+mScrollView.getChildCount());
    				}
    			} else {
    				mCellLayout =(CellLayout)mScrollView.getChildAt(pageID);
    			}
                if(mCellLayout == null){
                	mCellLayout = mContent;
                }
			}
        	
            View v = list.get(i);
            mCellLayout.getVacantCell(vacant, 1, 1);
            CellLayout.LayoutParams lp = (CellLayout.LayoutParams) v.getLayoutParams();
            lp.cellX = vacant[0];
            lp.cellY = vacant[1];
            ItemInfo info = (ItemInfo) v.getTag();
            if (info.cellX != vacant[0] || info.cellY != vacant[1]) {
                info.cellX = vacant[0];
                info.cellY = vacant[1];
                // Add to debug that item's cellX or cellY changed Jing.Wu 20160826 start
                synchronized (LauncherModel.sBgLock) {
                	ItemInfo mBgItemInfo = LauncherModel.sBgItemsIdMap.get(info.id);
                	if (mBgItemInfo!=null) {
                		mBgItemInfo.cellX = vacant[0];
                    	mBgItemInfo.cellY = vacant[1];
                    	LauncherModel.sBgItemsIdMap.put(info.id, mBgItemInfo);
					}
    			}
                // Add to debug that item's cellX or cellY changed Jing.Wu 20160826 end
                /// M: [OP09] support all app & folder.
                if (mSupportEditAndHideApps && isPageViewFolder()) {
                    LauncherModel.moveAllAppsItemInDatabase(mLauncher, info, mInfo.id, 0,
                            info.cellX, info.cellY);
                } else {
                    LauncherModel.addOrMoveItemInDatabase(mLauncher, info, mInfo.id, 0,
                            info.cellX, info.cellY);
                }
            }
            boolean insert = false;

            mCellLayout.addViewToCellLayout(v, insert ? 0 : -1, (int)info.id, lp, true);
        }
        
        if (mScrollView.getChildAt(mScrollView.getChildCount()-1) != null) {
        	mScrollView.getChildAt(mScrollView.getChildCount()-1).invalidate();
		}
        mItemsInvalidated = true;
    }

    private int mRom =3;
    private int mVertical = 4;
    
    private void removeCellIcon(int mPageN,int cellY,View v){

		if ((mScrollView.getChildCount()-1)>=mPageN && mScrollView.getChildAt(mPageN) != null) {
			((CellLayout)mScrollView.getChildAt(mPageN)).removeView(v);
		}
    }
  
    
    private void addContent(){
    	CellLayout mTempContent = (CellLayout)mLauncher.getLayoutInflater().inflate(R.layout.workspace_screen,null);
		mScrollView.addView(mTempContent);
    	grid = app.getDynamicGrid().getDeviceProfile();

         /// M: customize folder cell height to show text with two lines completely on CT project.
    	mTempContent.setCellDimensions(mGridCellWidth,mGridCellHeigth);
    	 
    	mTempContent.setGridSize(mMaxCountX, mMaxCountY);
    	mTempContent.getShortcutsAndWidgets().setMotionEventSplittingEnabled(false);
    	mTempContent.setInvertIfRtl(true);
    	
    }
    
    private void addScrollView(){
    	int mAllSize = mInfo.contents.size();
    	int mOnePageItem = mMaxCountX * mMaxCountY;
    	int totalContentNumb = ((mAllSize-(mAllSize>0?1:0))/mOnePageItem)+1;
    	int currentChildContentNumb = mScrollView.getChildCount();
    	if (currentChildContentNumb!=totalContentNumb) {
        	if (currentChildContentNumb<totalContentNumb) {
    			for (int i = currentChildContentNumb; i < totalContentNumb; i++) {
    				addContent();
    			}
    		} else if (currentChildContentNumb>totalContentNumb) {
    			for (int i = currentChildContentNumb-1; i >= totalContentNumb; i--) {
					if (mScrollView.getChildAt(i)!=null) {
						((CellLayout)mScrollView.getChildAt(i)).removeAllViews();
						mScrollView.removeViewAt(i);
					}
				}
    			//mScrollView.removeViews(totalContentNumb, (currentChildContentNumb-totalContentNumb));
    		}
		}
    	
		mScrollView.postInvalidate();
		ShowPageNumber(mScrollView.getChildCount(), mScrollView.getCurScreen());
    }

	
	ImageView inactive;
	ImageView active;
	
	public void ShowPageNumber(int allPage,int curPage){
		if(curPage >= allPage || curPage < 0){
			return ;
		}
		
		//sunfeng add @20150812 start:
		LinearLayout.LayoutParams lp = null;
		lp=	new LinearLayout.LayoutParams(DynamicGrid.pxFromDp(15, getResources().getDisplayMetrics()),
				DynamicGrid.pxFromDp(15, getResources().getDisplayMetrics()));//LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
		lp.leftMargin =DynamicGrid.pxFromDp(4, getResources().getDisplayMetrics());
		//sunfeng add @20150812 end:
		folderPageIndicator.removeAllViews();
		for(int i = 0;i < allPage;i++){
			PageIndicatorMarker m =
					(PageIndicatorMarker) LayoutInflater.from(mLauncher).inflate(R.layout.page_indicator_marker,null, false);
			active =(ImageView) m.findViewById(R.id.active);
			inactive =(ImageView) m.findViewById(R.id.inactive);

			//inactive.setImageResource(R.drawable.ic_pageindicator_default);
			inactive.setImageResource(R.drawable.workspace_page_view_default_color);
			if(i== curPage){
				//inactive.setImageResource(R.drawable.ic_pageindicator_current);
				inactive.setImageResource(R.drawable.workspace_page_view_current_color);
			}
			folderPageIndicator.addView(m , i, lp);
		}
		
		folderPageIndicator.setVisibility(allPage == 1?View.INVISIBLE: View.VISIBLE);
		
	}
	
    
    public int getItemCount() {
    	//return mContent.getShortcutsAndWidgets().getChildCount();
    	return mInfo.contents.size();
    }

    public View getItemAt(int index) {
    	CellLayout mCellLayout =  null;
    	int mNumIndex= index;
    	int OnePageNum = mMaxCountX * mMaxCountY;
    	int pageID = index/OnePageNum;
    	if ((mScrollView.getChildCount()-1)>=pageID && mScrollView.getChildAt(pageID)!=null) {
			mCellLayout = (CellLayout)mScrollView.getChildAt(pageID);
			mNumIndex = index-pageID*OnePageNum;
		} else {
			return null;
		}
    	
        return mCellLayout.getShortcutsAndWidgets().getChildAt(mNumIndex);
    }

    private void onCloseComplete() {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onCloseComplete: parent = " + getParent());
        }

        DragLayer parent = (DragLayer) getParent();
        if (parent != null) {
            parent.removeView(this);
        }
        mDragController.removeDropTarget((DropTarget) this);
        clearFocus();
        mFolderIcon.requestFocus();

        getInfo().opened = false;
        mFolderIcon.invalidate();        
        
        if (mRearrangeOnClose) {
            setupContentForNumItems(getItemCount());
            mRearrangeOnClose = false;
        }
        if (getItemCount() <= 1) {
            if (!mDragInProgress && !mSuppressFolderDeletion) {
                replaceFolderWithFinalItem();
            } else if (mDragInProgress) {
                mDeleteFolderOnDropCompleted = true;
            }
        }
        mSuppressFolderDeletion = false;
    }

    /***
     *  folder one  to delete Folder  add icon to workspace
     */
    private void replaceFolderWithFinalItem() {
        // Add the last remaining child to the workspace in place of the folder
        Runnable onCompleteRunnable = new Runnable() {
            @Override
            public void run() {
                if (mSupportEditAndHideApps && isPageViewFolder()) {
                    // M:[OP09][CF] @{
                    final AppsCustomizePagedView pageview = mLauncher.getPagedView();
                    final AppsCustomizeCellLayout celllayout = (AppsCustomizeCellLayout) pageview
                            .getPageAt((int) mInfo.screenId);
                    BubbleTextView child = null;
                    LauncherLog.d(TAG, "replaceFolderWithFinalItem, count = " + getItemCount());
                    if (getItemCount() == 1 && mInfo.contents.size() == 1) {
                        ShortcutInfo finalItem = mInfo.contents.get(0);
                        AppInfo info = finalItem.makeAppInfo();
                        LauncherLog.d(TAG, "replaceFolderWithFinalItem, info = " + info);
                        info.container = AllApps.CONTAINER_ALLAPP;
                        info.screenId = mInfo.screenId;
                        info.cellX = mInfo.cellX;
                        info.cellY = mInfo.cellY;
                        info.mPos = mInfo.cellY * AllApps.sAppsCellCountX + mInfo.cellX;
                        if (AppsCustomizePagedView.isHideApps(info)) {
                            info.isVisible = false;
                        } else {
                            child = (BubbleTextView) LayoutInflater.from(getContext()).inflate(
                                    R.layout.apps_customize_application, celllayout, false);
                            if (Launcher.DISABLE_APPLIST_WHITE_BG) {
                                child.setTextColor(getContext().getResources().getColor(
                                                R.color.quantum_panel_transparent_bg_text_color));
                            }
                            // update the delete button
                            if (Launcher.isInEditMode()) {
                                child.setDeleteButtonVisibility(!pageview.isSystemApp(info));
                            }
                            child.applyFromApplicationInfo(info);
                            child.setOnClickListener(pageview);
                            child.setOnLongClickListener(pageview);
                            child.setOnTouchListener(pageview);
                            child.setOnKeyListener(pageview);
                        }
                        // todolei:the last final item need how to do ?
                        LauncherModel.moveAllAppsItemInDatabase(mLauncher, info,
                                AllApps.CONTAINER_ALLAPP, mInfo.screenId, mInfo.cellX, mInfo.cellY);
                        if (info.isVisible) {
                            pageview.addOrRemoveApp(info, true);
                        } else {
                            pageview.addAppToList(info);
                        }

                        mInfo.contents.remove(0);
                        final View v = getViewForInfo(finalItem);
                        if (v != null) {
                        	getContent().removeView(v);
                        }
                    }
                    if (getItemCount() <= 1) {
                        // Remove the folder
                        LauncherLog.d(TAG, "replaceFolderWithFinalItem, remove folder");
                        LauncherModel.deleteFolderItemFromDatabase(getContext(), mInfo);
                        if (celllayout != null) {
                            // b/12446428 -- sometimes the cell layout has already gone away?
                            celllayout.removeView(mFolderIcon);
                        }
                        if (mFolderIcon instanceof DropTarget) {
                            mDragController.removeDropTarget((DropTarget) mFolderIcon);
                        }
                        //Remove folder
                        mLauncher.getPagedView().addOrRemoveFolder(mInfo, false);
                    }
                    if (child != null) {
                        //update cell info again after drag and drop before use add by lei:
                        int pos = mInfo.cellY * AllApps.sAppsCellCountX + mInfo.cellX;
                        LauncherLog.d(TAG, "replaceFolderWithFinalItem, pos = " + pos
                           + ", child=" + child + ",x=" + mInfo.cellX + ",y=" + mInfo.cellY);
                        celllayout.addViewToCellLayout(child, -1, pos,
                                new CellLayout.LayoutParams(mInfo.cellX, mInfo.cellY, 1, 1), false);
                        
                    }
                    //M:[OP09][CF] }@
                } else {
                    CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container,
                         mInfo.screenId);
                    View child = null;
                    // Move the item from the folder to the workspace, in the position of the folder
                    LauncherLog.d(TAG, "replaceFolderWithFinalItem, count = " + getItemCount());
                    if (getItemCount() == 1) {
                        ShortcutInfo finalItem = mInfo.contents.get(0);
                        child = mLauncher.createShortcut(R.layout.application, cellLayout,
                                finalItem);
                        LauncherModel.addOrMoveItemInDatabase(mLauncher, finalItem, mInfo.container,
                                mInfo.screenId, mInfo.cellX, mInfo.cellY);
                        // Add for MyUI Jing.Wu 20161211 start
                        synchronized (LauncherModel.sBgLock) {
                        	ItemInfo mBgItemInfo = LauncherModel.sBgItemsIdMap.get(finalItem.id);
                        	mBgItemInfo.container = mInfo.container;
                        	mBgItemInfo.screenId = mInfo.screenId;
                        	mBgItemInfo.cellX = mInfo.cellX;
                        	mBgItemInfo.cellY = mInfo.cellY;
                        	LauncherModel.sBgItemsIdMap.put(finalItem.id, mBgItemInfo);
            			}
                        // Add for MyUI Jing.Wu 20161211 end
                    }
                    if (getItemCount() <= 1) {
                        // Remove the folder
                        LauncherModel.deleteItemFromDatabase(mLauncher, mInfo);
                        if (cellLayout != null) {
                            // b/12446428 -- sometimes the cell layout has already gone away?
                            cellLayout.removeView(mFolderIcon);
                        }
                        if (mFolderIcon instanceof DropTarget) {
                            mDragController.removeDropTarget((DropTarget) mFolderIcon);
                        }
                        mLauncher.removeFolder(mInfo);
                    }
                    // We add the child after removing the folder to prevent both from existing at
                    // the same time in the CellLayout.  We need to add the new item with
                    //addInScreenFromBind()  to ensure that hotseat items are placed correctly.
                    if (child != null) {
                        mLauncher.getWorkspace().addInScreenFromBind(child, mInfo.container,
                                mInfo.screenId,
                                mInfo.cellX, mInfo.cellY, mInfo.spanX, mInfo.spanY);
                    }
                }
            }//end run
        };

        // M:[OP09][CF]
        if (mSupportEditAndHideApps && isPageViewFolder()
                && mLauncher.getPagedView().isInHideOrRemoveAppMode) {
            onCompleteRunnable.run();
        } else {
            View finalChild = getItemAt(0);
            if (finalChild != null) {
                mFolderIcon.performDestroyAnimation(finalChild, onCompleteRunnable);
            } else {
                onCompleteRunnable.run();
            }
        }

        mDestroyed = true;
    }

    boolean isDestroyed() {
        return mDestroyed;
    }

    // This method keeps track of the last item in the folder for the purposes
    // of keyboard focus
    private void updateTextViewFocus() {
        View lastChild = getItemAt(getItemCount() - 1);
        getItemAt(getItemCount() - 1);
        if (lastChild != null) {
            mFolderName.setNextFocusDownId(lastChild.getId());
            mFolderName.setNextFocusRightId(lastChild.getId());
            mFolderName.setNextFocusLeftId(lastChild.getId());
            mFolderName.setNextFocusUpId(lastChild.getId());
        }
    }

    public void onDrop(DragObject d) {
    	
        Runnable cleanUpRunnable = null;

        // If we are coming from All Apps space, we defer removing the extra empty screen
        // until the folder closes
        if (d.dragSource != mLauncher.getWorkspace() && !(d.dragSource instanceof Folder)) {
            cleanUpRunnable = new Runnable() {
                @Override
                public void run() {
                    mLauncher.exitSpringLoadedDragModeDelayed(true,
                            Launcher.EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT,
                            null);
                }
            };
        }
        
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onDrop: DragObject = "+d+", mIsExternalDrag = "+mIsExternalDrag
            		+", mCurrentDragInfo = "+mCurrentDragInfo
            		+", mScrollView = "+mScrollView+"!--------");
        }

        View currentDragView;
        ShortcutInfo si = mCurrentDragInfo;
        if (mIsExternalDrag) {
            si.cellX = mEmptyCell[0];
            si.cellY = mEmptyCell[1];

            // Actually move the item in the database if it was an external drag. Call this
            // before creating the view, so that ShortcutInfo is updated appropriately.
            /// M: [OP09] support all app & folder.
            if (mSupportEditAndHideApps && isPageViewFolder()) {
                LauncherModel.moveAllAppsItemInDatabase(
                        mLauncher, si, mInfo.id, 0, si.cellX, si.cellY);
            } else {
                LauncherModel.addOrMoveItemInDatabase(
                        mLauncher, si, mInfo.id, 0, si.cellX, si.cellY);
            }

            // We only need to update the locations if it doesn't get handled in #onDropCompleted.
            if (d.dragSource != this) {
                updateItemLocationsInDatabaseBatch();
            }
            mIsExternalDrag = false;

            // Modify for open folder Jing.Wu 20151105 start
            CellLayout mCellLayout =(CellLayout)mScrollView.getChildAt(mScrollView.getCurScreen());
            currentDragView = createAndAddShortcut(mCellLayout ,si);
            // Modify for open folder Jing.Wu 20151105 end
        } else {
        	/**
        	 * drag to xy 
        	 */
            currentDragView = mCurrentDragView;
            CellLayout.LayoutParams lp = (CellLayout.LayoutParams) currentDragView.getLayoutParams();
            si.cellX = lp.cellX = mEmptyCell[0];
            si.cellX = lp.cellY = mEmptyCell[1];
        	
        	CellLayout mCellLayout = mContent;
        	if (QCConfig.supportMultiCellInFolder) {
				mCellLayout = (CellLayout)mScrollView.getChildAt(mScrollView.getCurScreen());
	        	if (mCellLayout == null) {
					mCellLayout = mContent;
				}
			}
        	
            mCellLayout.addViewToCellLayout(currentDragView, -1, (int) si.id, lp, true);
        }

        if (d.dragView.hasDrawn()) {

            // Temporarily reset the scale such that the animation target gets calculated correctly.
            float scaleX = getScaleX();
            float scaleY = getScaleY();
            setScaleX(1.0f);
            setScaleY(1.0f);
            mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, currentDragView,
                    cleanUpRunnable, null);
            setScaleX(scaleX);
            setScaleY(scaleY);
        } else {
            d.deferDragViewCleanupPostAnimation = false;
            currentDragView.setVisibility(VISIBLE);
        }
        //mItemsInvalidated = true;
        //setupContentDimensions(getItemCount());

        // Temporarily suppress the listener, as we did all the work already here.
        mSuppressOnAdd = true;
        mInfo.add(si);
        mSuppressOnAdd = false;
        mItemsInvalidated = true;
        setupContentDimensions(getItemCount());
        //sunfeng modfiy for folder onLong show item
        //If OP09, need reorder its position
        if (mSupportEditAndHideApps && isPageViewFolder()) {
            int dragScreenId = (int) ((ItemInfo) d.dragInfo).screenId;
            int currentScreenId = (int) mInfo.screenId;
            if (dragScreenId == currentScreenId && ((ItemInfo) d.dragInfo).container != mInfo.id) {
                final AppsCustomizePagedView pageview = mLauncher.getPagedView();
                int[] emptyCell = new int[2];
                emptyCell[0] = ((ItemInfo) d.dragInfo).cellX;
                emptyCell[1] = ((ItemInfo) d.dragInfo).cellY;
                int[] targetCell = new int[2];
                targetCell[0] = mInfo.cellX;
                targetCell[1] = mInfo.cellY;
                LauncherLog.d(TAG, "onDrop: emptyCell = (" + emptyCell[0] + "," + emptyCell[1]
                                   + "), App.mEmptyCell=("
                                    + pageview.mEmptyCell[0]  + ","
                                    + pageview.mEmptyCell[1] + ")");

                if (emptyCell[0] != pageview.mEmptyCell[0]
                    && pageview.mEmptyCell[0] != -1) {
                    emptyCell[0] = pageview.mEmptyCell[0];
                }
                if (emptyCell[1] != pageview.mEmptyCell[1]
                    && pageview.mEmptyCell[1] != -1) {
                    emptyCell[1] = pageview.mEmptyCell[1];
                }
                AppsCustomizeCellLayout layout = (AppsCustomizeCellLayout) pageview
                    .getPageAt(dragScreenId);
                LauncherLog.d(TAG, "onDrop: dragScreenId = " + dragScreenId
                    + ", currentScreen = " + currentScreenId
                    + ", targetCell=(" + targetCell[0] + "," + targetCell[1] + "), emptyCell=("
                    + emptyCell[0]  + "," + emptyCell[1] + ")"
                    + ", layout = " + layout);
                pageview.reorderForFolderCreateOrDelete(emptyCell, targetCell, layout, true);
                // Update all apps position in the page after realTimeReorder.
                pageview.updateItemLocationsInDatabase(layout);
            }
        }
        // Clear the drag info, as it is no longer being dragged.
        mCurrentDragInfo = null;
    }

    // This is used so the item doesn't immediately appear in the folder when added. In one case
    // we need to create the illusion that the item isn't added back to the folder yet, to
    // to correspond to the animation of the icon back into the folder. This is
    public void hideItem(ShortcutInfo info) {
        View v = getViewForInfo(info);
        if(v!=null)
        v.setVisibility(INVISIBLE);
    }
    public void showItem(ShortcutInfo info) {
        View v = getViewForInfo(info);
        if(v!=null)
        v.setVisibility(VISIBLE);
    }

    public void onAdd(ShortcutInfo item) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onAdd item = " + item);
        }
        
        mItemsInvalidated = true;
        // If the item was dropped onto this open folder, we have done the work associated
        // with adding the item to the folder, as indicated by mSuppressOnAdd being set
        if (mSuppressOnAdd) return;
        
        if (QCConfig.supportMultiCellInFolder) {
        	addScrollView();
		}

    	CellLayout mCellLayout = mContent;
    	if (QCConfig.supportMultiCellInFolder) {
			mCellLayout = (CellLayout)mScrollView.getChildAt(mScrollView.getChildCount()-1);
	    	if (mCellLayout == null) {
				mCellLayout = mContent;
			}
		}
        
        /**
         * findAndSetEmptyCells false one Row  
         * findAndSetEmptyCells add one Row 
         */
        if (!findAndSetEmptyCells(mCellLayout,item)) {
            // The current layout is full, can we expand it?
        	/**
        	 * pre icon invalidate
        	 */
            setupContentForNumItems(getItemCount() + 1);
            findAndSetEmptyCells(mCellLayout,item);
        }
        createAndAddShortcut(mCellLayout,item);

        /// M: [OP09] support all app & folder.
        if (mSupportEditAndHideApps && isPageViewFolder()) {
            LauncherModel.moveAllAppsItemInDatabase(
                    mLauncher, item, mInfo.id, 0, item.cellX, item.cellY);
        } else {
            LauncherModel.addOrMoveItemInDatabase(
                    mLauncher, item, mInfo.id, 0, item.cellX, item.cellY);
        }
    }

    public void onRemove(ShortcutInfo item) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onRemove item = " + item);
        }

        mItemsInvalidated = true;
        // If this item is being dragged from this open folder, we have already handled
        // the work associated with removing the item, so we don't have to do anything here.
        if (item == mCurrentDragInfo) return;
        View v = getViewForInfo(item);
        
        removeCellIcon(mScrollView.getCurScreen(),item.cellY, v);
        if (mState == STATE_ANIMATING) {
            mRearrangeOnClose = true;
        } else {
            setupContentForNumItems(getItemCount());
        }
        if (getItemCount() <= 1) {
            replaceFolderWithFinalItem();
        }
    }

    private CellLayout getContextCellLayout(ShortcutInfo item){
    	CellLayout cellLayout = null;
    	int mOnePageItem = mMaxCountX* mMaxCountY;
    	int num = mInfo.contents.indexOf(item);
		int pageID = num/mOnePageItem;
        if ((mScrollView.getChildCount()-1) >= pageID && mScrollView.getChildAt(pageID)!=null) {
        	cellLayout =(CellLayout)mScrollView.getChildAt(pageID);
		}
        if(cellLayout == null){
        	cellLayout = mContent;
        }
    	
    	return cellLayout;
    }
    
    private View getViewForInfo(ShortcutInfo item) {
    	View v =null;
    	CellLayout mCellLayout = getContextCellLayout(item);
        try {
			for (int j = 0; j < mCellLayout.getCountY(); j++) {
			    for (int i = 0; i < mCellLayout.getCountX(); i++) {
			        v = mCellLayout.getChildAt(i, j);
			        if (v.getTag() == item) {
			            return v;
			        }
			    }
			}
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			for (int j = 0; j < mContent.getCountY(); j++) {
			    for (int i = 0; i < mContent.getCountX(); i++) {
			        v = mContent.getChildAt(i, j);
			        if (v.getTag() == item) {
			            return v;
			        }
			    }
			}
		}
        return v;
    }

    public void onItemsChanged() {
        updateTextViewFocus();
    }

    public void onTitleChanged(CharSequence title) {
    	if (mInfo!=null) {
    		mInfo.title = title.toString();
		}
    	if (mFolderName!=null) {
			mFolderName.setText(title);
		}
    }
    
    public ArrayList<View> getItemsInReadingOrder() {
        if (mItemsInvalidated) {
            mItemsInReadingOrder.clear();
            /**
             * add temp data 
             */
            CellLayout mCellLayout = null;
            for (int K = 0; K < mScrollView.getChildCount(); K++) {
				if (mScrollView.getChildAt(K) != null) {
					mCellLayout = (CellLayout)mScrollView.getChildAt(K);
					for (int j = 0; j < mCellLayout.getCountY(); j++) {
		                for (int i = 0; i < mCellLayout.getCountX(); i++) {
		                    View v = mCellLayout.getChildAt(i, j);
		                    if (v != null) {
		                        mItemsInReadingOrder.add(v);
		                        
		                    }
		                }
		            }
				}
			}
            mItemsInvalidated = false;
        }
        return mItemsInReadingOrder;
    }

    public void getLocationInDragLayer(int[] loc) {
        mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
    }

    public void onFocusChange(View v, boolean hasFocus) {
        if (v == mFolderName && hasFocus) {
            startEditingFolderName();
        }
    }

    @Override
    public void getHitRectRelativeToDragLayer(Rect outRect) {
        getHitRect(outRect);
    }
    
    /**
     * M: Update unread number of the content shortcut.
     */
    public void updateContentUnreadNum() {
        if (LauncherLog.DEBUG_UNREAD) {
            LauncherLog.d(TAG, "Folder updateContentUnreadNum: mInfo = " + mInfo);
        }
        ShortcutAndWidgetContainer container = (ShortcutAndWidgetContainer)getContent().getShortcutsAndWidgets();
        int childCount = container.getChildCount();
        for(int i=0;i<childCount;i++){
            BubbleTextView shortcut = (BubbleTextView) container.getChildAt(i);
            if (shortcut != null) {
                shortcut.invalidate();
            }
        }
    }

    //M:[OP09][CF] @{
    void setIsPageViewFolder(boolean isPageViewFolder) {
        this.mIsPageViewFolder = isPageViewFolder;
    }

    boolean isPageViewFolder() {
        return mIsPageViewFolder;
    }

    FolderIcon getFolderIcon() {
        return mFolderIcon;
    }

    /**
     * M: Update system delete of the content shortcut.
     */
    void updateContentDeleteButton() {
        ShortcutAndWidgetContainer container = (ShortcutAndWidgetContainer)
        		getContent().getShortcutsAndWidgets();
        int childCount = container.getChildCount();
        for (int i = 0; i < childCount; i++) {
            BubbleTextView shortcut = (BubbleTextView) container.getChildAt(i);
            if (shortcut != null) {
                shortcut.invalidate();
            }
        }
    }
    //M:[OP09][CF] }@
}

	//sunfeng modfiy @20150802 for folder end
